# Today I Learned

|date|ver|
|----|----|
|2022-12-14| v1.0|
---
## 오늘 배운 것
### fetch join
* SQL에서 제공하는 join X
* JPQL에서 성능 최적화 위해 제공하는 기능
* 연관된 엔티티나 컬렉션 SQL 한번에 조회하는 기능
* n + 1 문제 해결에 도움
* 즉시 로딩과 비슷한 느낌이지만 약간 다름
* 즉시 로딩은 join으로 가져오지 않고 일단 주 객체 먼저 다 조회하고 그 후에 연관된 애 하나하나 조회하는 n + 1 문제 발생시킴
* fetch join은 조인을 통해서 한번에 연관된 객체까지 다 채움
* 지연로딩으로 설정해놔도 fetch join이 우선임
* 문제
    * 일대다 관계에서 데이터 뻥튀기 됨
    * 가져오는 객체는 1개인데 거기에 딸린 객체가 여러개이다 보니
    * 연관된 객체 수만큼 주 객체가 중복되는 문제 발생
    * 데이터 가져오는 과정
        * 영속성 컨텍스트에 저장하면서 연관된 엔티티도 채워줌
        * 만약 주 객체가 이미 영속성 컨텍스트에 있다면 저장되어 있는 영속성 컨텍스트의 주 객체에 연관된 엔티티만 추가해줌
        * 끝날때까지 반복
        * 중복된 객체는 같은 참조값을 가지지만, 반환활 때는 중복된 객체를 그대로 반환함
        * 어쨋든 SQL에서 반환하는 개수와 JPA에서 반환하는 개수를 맞춰야 한다는 스펙을 잡은듯
        * 중복 제거를 하고 싶으면 distinct 키워드를 사용
        * SQL에서 사용하는 거 말고 JPQL에서 distinct 사용하면 애플리케이션 단에서 중복 제거 해줌
        
### 일반 조인과의 차이
* 일반 조인은 연관된 엔티티 함께 조회 하지 않음
* 그냥 조인문만 SQL에 추가된 것

### 주의점
* fetch join 대상에는 별칭 줄 수 없음
    * 일반적으로 fetch join을 쓸 때는 주 객체와 연관된 모든 엔티티를 전부 다 끌고 오겠다는 목적인데, 별칭으로 조건을 줘버리면 목적에 어긋남
    * 필터링을 하고 싶다면 그에 맞는 쿼리를 따로 작성하는게 맞음
    * 객체 그래프가 끊어지지 않고 연결된 전부를 가져올 수 있다는 신뢰하에 사용하는거라 이를 지켜야 함
* 둘 이상의 컬렉션 fetch join 불가
    * 이미 1:n 관계에서도 데이터 뻥튀기가 일어났는데 1:n:n... 은 더 위험
    * 데이터 정합성 안 맞을 가능성 높음
* 컬렉션 fetch join 하는 경우 페이징 API 사용 불가
    * 데이터 뻥튀기 등등의 문제 있음..
    * 결과가 제대로 나오지 않음
* 해결법
    * 다대일로 봤을 땐 문제 없으니 다대일로 접근하기
    * @BatchSize 옵션 주기
        * 페이징 제대로 사용할 수 있고, fetch join 대신 n + 1 문제 해결 가능